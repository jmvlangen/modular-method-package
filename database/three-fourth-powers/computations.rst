=======================================================
 On the equation :math:`(x-y)^4 + x^4 + (x+y)^4 = z^n`
=======================================================

In this document we give all the computations done for the paper.

.. linkall

Throughout :math:`(a, b, c)` will be a primitive solution to
:math:`(x-y)^4 + x^4 + (x+y)^4 = z^l` with :math:`l` a prime
number. We will also use the variable ``cl`` to denote :math:`c^l`.

::

   sage: R.<a, b> = ZZ[]
   sage: cl = (a-b)^4 + a^4 + (a+b)^4; cl
   3*a^4 + 12*a^2*b^2 + 2*b^4
   sage: coprime = CoprimeCondition([a, b])
   sage: C = coprime & PowerCondition(cl, 3)

Preliminaries
=============

We first check that proposition 1.1 is indeed correct. Note that we
can check that ``cl`` is not equal to zero modulo 4 and 9 since if
``cl`` is divisible by either 2 or 3 it should be divisible by 4 or 9
as :math:`l > 1`.

::

   sage: all(cl(aa, bb) != 0 for aa, bb in Integers(4)^2 if not 2.divides(aa) or not 2.divides(bb))
   True
   sage: all(cl(aa, bb) != 0 for aa, bb in Integers(9)^2 if not 3.divides(aa) or not 3.divides(bb))
   True
   sage: all(cl(aa, bb) != 0 for aa, bb in GF(5)^2 if (aa, bb) != (0, 0))
   True

Next, we check there is indeed no primitive solution for :math:`l = 2`
as claimed in proposition 1.2.

::

   sage: all(not cl(aa, bb).is_square() for aa, bb in GF(3)^2 if (aa, bb) != (0, 0) and cl(aa, bb) != 0)
   True

Next we factor the polynomial ``cl`` as mentioned in the article over
the splitting field of :math:`3 x^4 + 12 x^2 + 2`. We also let
:math:`v` be a root of this polynomial and construct the polynomial
:math:`h`.

::

   sage: S.<x> = QQ[]
   sage: L.<vg> = cl(x, 1).splitting_field()
   sage: v = cl(x, 1).change_ring(L).roots()[0][0]
   sage: h = a + v*b

We verify that ``cl`` factors as in equation 3 and that the factors
are indeed galois conjugates of :math:`h`.

::

   sage: h1 = a - v*b
   sage: h2 = a + sqrt(-v^2 - 4)*b
   sage: h3 = a - sqrt(-v^2 - 4)*b
   sage: cl == 3 * h * h1 * h2 * h3
   True
   sage: G = L.galois_group()
   sage: h1 == h.change_ring(G[3].as_hom())
   True
   sage: h2 == h.change_ring(G[2].as_hom())
   True
   sage: h3 == h.change_ring(G[1].as_hom())
   True

We now perform the computations necessary for lemma 1.3, i.e. we check
there is a unique prime ``P3`` above 3 in :math:`L`, that :math:`v` is
only not integral at ``P3`` and has valuation -1 there, and that the
difference between galois conjugates of :math:`v` only contain primes
above 2, 3 and 5. Note that we also use the fact that ``P3`` to the
power four is 3, which we also verify here.

::

   sage: len(L.primes_above(3)) == 1
   True
   sage: P3 = L.prime_above(3)
   sage: P235 = L.primes_above(2*3*5)
   sage: all(P in P235 for P, e in L.ideal(v).factor())
   True
   sage: [(P, e) for P, e in L.ideal(v).factor() if e < 0] == [(P3, -1)]
   True
   sage: all(P in P235
   ....:     for sigma, tau in [(sigma, tau) for sigma in G for tau in G if sigma(v) != tau(v)]
   ....:     for P, e in L.ideal(sigma(v) - tau(v)).factor())
   True
   sage: P3^4 == L.ideal(3)
   True

We check that over the subfield :math:`K = \QQ(\sqrt{30})` of
:math:`L` the polynomial ``cl`` factors as in the article, and that
both factors are indeed the product of two galois conjugates of
:math:`h`.

::

   sage: K.<w> = L.subfield(-sqrt(L(30)), name='w')[0]
   sage: g1 = a^2 + (2 + w/3)*b^2
   sage: g2 = a^2 + (2 - w/3)*b^2
   sage: cl == 3 * g1 * g2
   True
   sage: g1 == h * h1
   True
   sage: g2 == h2 * h3
   True

We check that indeed :math:`K` has a unique prime ``Q3`` above 3 and
that it factors as the square of ``P3`` in :math:`L`.

::

   sage: len(K.primes_above(3)) == 1
   True
   sage: Q3 = K.prime_above(3)
   sage: L.ideal(Q3) == P3^2
   True

Case :math:`l = 5`
==================

We first check that 5 indeed does not divide the order of the class
group of :math:`L`.

::

   sage: 5.divides(L.class_number())
   False

Next we check that the argument given holds true if we replace
:math:`L` with the subfield :math:`\QQ(v)`. Since :math:`h` can be
defined over this subfield all we have to check is that the prime
above 3 in :math:`\QQ(v)` factors as ``P3`` in :math:`L` and that 5
again does not divide the order of the class group.

::

   sage: Qv = L.subfield(v, names='v')[0]
   sage: L.ideal(Qv.prime_above(3)) == P3
   True
   sage: 5.divides(Qv.class_number())
   False

We quickly verify that :math:`\QQ(v)` has degree 4 and parametrize the
elements of its ring of integers.

::

   sage: Qv.degree()
   4
   sage: R4.<s1, s2, s3, s4> = QQ[]
   sage: gamma = 1/3 * sum(product(term) for term in zip(R4.gens(), Qv.integral_basis()))

We check that the unit group of :math:`\QQ(v)` is indeed generated by
two generators ``u0`` and ``u1``, where ``u0`` = -1 and ``u1`` has
infinite order.

::

   sage: len(Qv.unit_group().gens())
   2
   sage: u0, u1 = Qv.unit_group().gens_values()
   sage: u0 == -1
   True
   sage: u1.multiplicative_order()
   +Infinity

We now generate the possible values of :math:`h(a, b)` inside
:math:`\QQ(v)`.

::

   sage: vals = [3 * u1^i * gamma^5 for i in range(5)]

Now we express each of these values in terms of the basis :math:`( 1,
v, v^2, v^3 )`.

::

   sage: B = [Qv(1), Qv(v), Qv(v)^2, Qv(v)^3]
   sage: valsB = [polynomial_split_on_basis(val, B) for val in vals]

Since each value is equal to :math:`h(a, b) = a + b v + 0 v^2 + 0 v^3`
with :math:`a` and :math:`b` integers we obtain for each i four
equations ``a == valsB[i][0]``, ``b == valsB[i][1]``, ``0 ==
valsB[i][2]`` and ``0 == valsB[i][3]`` over the rationals. We show
that these equations are actually integral except at 3.

::

   sage: all(p == 3 for valB in valsB for poly in valB for cf in poly.coefficients()
   ....:     for p in cf.denominator().prime_factors())
   True

This implies that we can consider the equations modulo 5. Now for each
choice of value of :math:`h(a, b)` we can express the value of the
tuple :math:`(a, b)` in a special way using the equations.

::

   sage: valsB5 = [[poly.change_ring(GF(5)) for poly in valB] for valB in valsB]
   sage: (valsB5[0][0],                 valsB5[0][1] -  valsB5[0][3])
   (s1^5 - s3^5, 0)
   sage: (valsB5[1][0] -  valsB5[1][2], valsB5[1][1] +  valsB5[1][3])
   (0, 0)
   sage: (valsB5[2][0] +  valsB5[2][2], valsB5[2][1])
   (0, 0)
   sage: (valsB5[3][0],                 valsB5[3][1] +2*valsB5[3][3])
   (0, 0)
   sage: (valsB5[4][0] +2*valsB5[4][2], valsB5[4][1] +  valsB5[4][3])
   (0, 2*s2^5 + s4^5)

This shows that in three of the five cases both :math:`a` and
:math:`b` must be divisible by 5, but as the solution is primitive
this is impossible. We are thus left with case 0 and case 4 as stated
in the article.

We take the automorphism :math:`\sigma` of :math:`\QQ(v)` that sends
:math:`v` to :math:`-v` and check that ``g1`` is indeed the product of
:math:`h` and :math:`\sigma(h)`.

::

   sage: sigma = Qv.hom([-Qv(v)])
   sage: g1 == h.change_ring(Qv) * h.change_ring(Qv).change_ring(sigma)
   True

We will construct the parametrizations as described in the article for
the remaining cases. First we parametrize what is called
:math:`\gamma'` and what we shall call ``gamma`` again here.

::

   sage: K.degree()
   2
   sage: R2.<t1, t2> = QQ[]
   sage: gamma = 1/3 * sum(product(term) for term in zip(R2.gens(), K.integral_basis()))

Next we find the possible values for :math:`g_1(a, b)`. Note that we
here only have to consider those units not eliminated by the argument
before.

::

   sage: vals = [9 * K(u1^i * sigma(u1^i)) * gamma^5 for i in [0, 4]]

Next we write each value in terms of the basis given by the
coefficients of ``g1``, which makes it so we get for each value two
equations over the rationals of the form :math:`a^2 = F(t_1, t_2)` and
:math:`b^2 = G(t_1, t_2)`.

::

   sage: B = g1.coefficients()
   sage: valsB = [polynomial_split_on_basis(val, B) for val in vals]

Since :math:`a^2` and :math:`b^2` are integers, we find that for each
value of :math:`g_1(a, b)` also :math:`F(t_1, t_2)` and :math:`F(t_1,
t_2)` should be integers. Note however that all these have a common
denominator that is not 1.

::

   sage: [lcm(cf.denominator() for cf in poly.coefficients())
   ....:  for valB in valsB for poly in valB]
   [27, 9, 27, 9]

In particular this implies that for each value of :math:`g_1(a, b)` we
have that :math:`27 F(t_1, t_2)` and :math:`9 G(t_1, t_2)` are
integers divisible by 3. We consider these quantities modulo 3 and
conclude that therefore :math:`t_1` should be divisible by 3.

::

   sage: [(27*valB[0]).change_ring(GF(3)) for valB in valsB]
   [t1^5, t1^5]
   sage: [(9*valB[1]).change_ring(GF(3)) for valB in valsB]
   [-t1^4*t2, -t1^5 - t1^4*t2]

We thus replace :math:`t_1` with :math:`3*t_1`, which gives us
integral equations.

::

   sage: valsB = [[poly(3*t1, t2) for poly in valB] for valB in valsB]
   sage: all(cf in ZZ for valB in valsB for poly in valB for cf in poly.coefficients())
   True

Now we note that if :math:`t_2 = 0` we get :math:`a^2` and :math:`b^2`
that are not coprime, which we can easily verify by seeing that they
both should be zero modulo 3. Therefore we have :math:`t_2 \ne 0`

::

   sage: [tuple(poly(t1, 0).change_ring(GF(3)) for poly in valB) for valB in valsB]
   [(0, 0), (0, 0)]

By multiplying both equations for a possible value of :math:`g_1(a,
b)` and dividing by :math:`t_2^{10}` we get a hyperelliptic curve in
terms of :math:`x = t_1 / t_2` and :math:`y = a * b / t_2^5`.

::

   sage: FG = [product(valB) for valB in valsB]
   sage: C_sage = [HyperellipticCurve(poly(x, 1)) for poly in FG]

We compute the factors of the product :math:`F(t_1, t_2) G(t_1, t_2)`.

::

   sage: [poly.factor for poly in FG]
   [(5) * t2 * (9*t1^4 + 60*t1^2*t2^2 + 20*t2^4) * (9*t1^5 - 90*t1^4*t2 + 300*t1^3*t2^2 - 600*t1^2*t2^3 + 500*t1*t2^4 - 200*t2^5),
    (-5) * (23*t1 + 42*t2) * (201580749*t1^4 + 1472068080*t1^3*t2 + 4031233980*t1^2*t2^2 + 4906429920*t1*t2^3 + 2239362820*t2^4) * (133031294352*t1^5 + 1214404012845*t1^4*t2 + 4434376478400*t1^3*t2^2 + 8096026752300*t1^2*t2^3 + 7390627464000*t1*t2^4 + 2698675584100*t2^5)]

We thus see that both curves have a rational point corresponding to a
linear factor of :math:`F(t_1, t_2) G(t_1, t_2)` as these points
correspond to cases in which either :math:`F(t_1, t_2)` or
:math:`G(t_1, t_2)` is zero, i.e. in which either :math:`a` or
:math:`b` is zero. The article already notes that trivial solutions
can not be primitive.

Since we have a rational point on both curves and for both curves the
polynomial in :math:`x` splits into two other factors, we have found
two points on the jacobian of these curves. We shall show that these
are the only two points on the jacobian, thereby proving the
non-existence of solutions in the case :math:`l = 5`.
   
For the computation we turn our Sage objects into a magma
objects.

::
   
   sage: C_magma = [magma(C) for C in C_sage]
   sage: J_magma = [C.Jacobian() for C in C_magma]

Now we bound the number of points on the Jacobians by first computing
a bound on their rank and then a bound on the number of torsion points.

::

   sage: [J.RankBound() for J in J_magma]
   [0, 0]
   sage: [J.TorsionBound(50) for J in J_magma]
   [4, 4]

Both jacobian have thus at most 4 points. We can tell the order of
these torsion points by the fact that torsion points map injectively
to the jacobian of the reduction of the curve at any prime of good
reduction. We show that 7 is a prime of good reduction for both curves
and show that in the jacobian of the reduction of each curve at 7 does
not contain a point of order 4.

::

   sage: all(7 not in C.BadPrimes().sage() for C in C_magma)
   True
   sage: J7 = [C.ChangeRing(GF(7)).Jacobian() for C in C_magma]
   sage: all(not 4.divides(g.Order()) for J in J7 for g in J.AbelianGroup().Generators())
   True

Now it remains to compute the size of the two torsion groups of both
jacobians. Note that for the second case we first have to obtain an
odd degree model of the curve.

::

   sage: J_magma[0].TwoTorsionSubgroup().Order()
   2
   sage: C_magma[1].HasOddDegreeModel(nvals=2)[1].Jacobian().TwoTorsionSubgroup().Order()
   2

Modular method
==============

We first of all define the elliptic curves presented in the article.

::

   sage: G.<sigma> = K.galois_group()
   sage: Qm2.<sqrtm2> = QuadraticField(-2)
   sage: isogenies = {sigma^0: (QQ(1), 1), sigma^1: (sqrtm2, 2)}
   sage: a_invariants1 = [0, 60*a, 0, 30*((15 + 3*w)*a^2 + w*b^2), 0]
   sage: E1 = FreyQcurve(a_invariants1, isogenies=isogenies, condition=C)
   sage: a_invariants2 = [0, 40*b, 0, 20*(w*a^2 + (10 + 2*w)*b^2), 0]
   sage: E2 = FreyQcurve(a_invariants2, isogenies=isogenies, condition=C)

We check that the invariants listed of these curves are indeed
correct.

::

   sage: E1.discriminant() == - 2^9 * 3^6 * 5^4 * (5 + w) * g1 * g2^2
   True
   sage: E2.discriminant() == - 2^13 * 3 * 5^4 * w * g1^2 * g2
   True
   sage: E1.c4() == - 2^5 * 3^2 * 5 * (5 + w) * ((43 - 8*w)*a^2 + (6 - w)*b^2)
   True
   sage: E2.c4() == - 2^6 * 5 * (5 + w) * ((18 - 3*w)*a^2 + (86 - 16*w)*b^2)
   True
   sage: E2.c4() == - 2^6 * 3^(-1) * 5 * w * (9*a^2 + (18 - 5*w)*b^2)
   True
   sage: E1.j_invariant() == (11 + 2*w) * 2^6 * ((43 - 8*w)*a^2 + (6 - w)*b^2)^3 / (g1 * g2^2)
   True
   sage: E2.j_invariant() == 2^6 * 3^(-3) * (9*a^2 + (18 - 5*w)*b^2)^3 / (g1^2 * g2)
   True

We show that the resultants of :math:`g_1` and :math:`g_2` with the
factors in the numerators of :math:`j_1` and :math:`j_2` are indeed
only divisible by primes dividing 2, 3 or 5, affirming the statement
made in Lemma 3.1. For this we simply compute the prime factors in the
norm, which is sufficient as the numerators are integral and the only
prime at which :math:`g_1` and :math:`g_2` are not integral divides 3.

::

   sage: g1.macaulay_resultant(9*a^2 + (18 + 5*w)*b^2).norm().factor()
   2^6 * 3^2 * 5^2
   sage: g1.macaulay_resultant((7 - 2*w)*a^2 + (w - 6)*b^2).norm().factor()
   2^14 * 3^-2 * 5^2
   sage: g2.macaulay_resultant(9*a^2 + (18 + 5*w)*b^2).norm().factor()
   2^14 * 3^2 * 5^2
   sage: g2.macaulay_resultant((7 - 2*w)*a^2 + (w - 6)*b^2).norm().factor()
   2^6 * 3^-2 * 5^2

We now perform the computational part of theorem 3.3. We check for
:math:`l = 3, 5, 7, 13` that the curve :math:`X_0(2l)` has no
:math:`K` point corresponding to a :math:`\QQ` point on :math:`X_0(2l)
/ w_2`.

We start with the case :math:`l = 7`, in which the modular curve is an
elliptic curve.

::

   sage: magma.eval("X14 := SmallModularCurve(14);");
   sage: magma.eval("w2 := AtkinLehnerInvolution(X14, 14, 2);");
   sage: print(magma.eval("Genus(X14);"))
   1

The morphism :math:`w_2` is a combination of an isogeny with a
translation. Since :math:`w_2` is an isomorphism, the isogeny must be
an ismorphism as well and :math:`w_2` is essentially defined as a
translation, which is given by where :math:`w2` maps the point at
infinity. We use this to compute the quotient :math:`X_0(14) / w_2` as
the quotient of the curve by the subgroup generated by this point. We
show this is an elliptic curve with 6 :math:`\QQ` points.

::

   sage: magma.eval("P := w2(X14 ! [0, 1, 0]);");
   sage: magma.eval("phi := TwoIsogeny(P);");
   sage: magma.eval("X14modW2 := Codomain(phi);");
   sage: print(magma.eval("Genus(X14modW2)"))
   1
   sage: print(magma.eval("AbelianGroup(X14modW2)"))
   Abelian Group isomorphic to Z/6
   Defined on 1 generator
   Relations:
   6*$.1 = 0
   Mapping from: Abelian Group isomorphic to Z/6
   Defined on 1 generator
   Relations:
   6*$.1 = 0 to Set of points of X14modW2 with coordinates in Rational Field given by a rule [no inverse]
   true true

We now show that we can find two :math:`\QQ(-7)` points on
:math:`X_0(14)` that maps to the generator of the :math:`\QQ` points
on this quotient. This proves that all :math:`\QQ` points on the
quotient come from :math:`\QQ(\sqrt{-7})` points and not from
:math:`K` points.

::

   sage: magma.eval("L := QuadraticField(-7);");
   sage: magma.eval("X14L := BaseChange(X14, L);");
   sage: magma.eval("phiL := TwoIsogeny(X14L ! P);");
   sage: magma.eval("P1 := Generators(X14L)[1];");
   sage: magma.eval("P2 := Generators(X14L)[2];");
   sage: magma.eval("Q := Generators(X14modW2)[1];");
   sage: print(magma.eval("X14modW2 ! phiL(P1 + P2) eq Q;"))
   true
   sage: print(magma.eval("X14modW2 ! phiL(P1 + 4*P2) eq Q;"))
   true
   sage: print(magma.eval("P1 + P2 eq P1 + 4*P2;"))
   false

We now perform the same procedure for the case :math:`l = 13`, only in
this case the curve :math:`X_0(26)` we start with has genus 2.

::

   sage: magma.eval("X26 := SmallModularCurve(26);");
   sage: magma.eval("w2 := AtkinLehnerInvolution(X26, 26, 2);");
   sage: print(magma.eval("Genus(X26);"))
   2

In this case we can obtain the quotient :math:`X_0(26) / w_2` as the
quotient by the automorphism subgroup generated by :math:`w_2`. This
quotient is an elliptic curve.

::

   sage: magma.eval("G2 := AutomorphismGroup(X26, [w2]);");
   sage: magma.eval("X26modW2, phi := CurveQuotient(G2);");
   sage: print(magma.eval("Genus(X26modW2);"))
   1

We show that the the curve :math:`X_0(26) / w_2` only has three
rational points and explicitly give the 6 points on :math:`X_0(26)`
that lie above them. Four of these points are :math:`\QQ` points and
two are :math:`\QQ(\sqrt{13})`, hence none can be :math:`K` points.

::

   sage: print(magma.eval("AbelianGroup(X26modW2);"))
   Abelian Group isomorphic to Z/3
   Defined on 1 generator
   Relations:
   3*$.1 = 0
   Mapping from: Abelian Group isomorphic to Z/3
   Defined on 1 generator
   Relations:
   3*$.1 = 0 to Set of points of X26modW2 with coordinates in Rational Field given by a rule [no inverse]
   true true
   sage: magma.eval("Q := Generators(X26modW2)[1];");
   sage: print(magma.eval("phi(X26 ! [0, 0, 1]) eq Q;"))
   true
   sage: print(magma.eval("phi(X26 ! [1, 0, 0]) eq Q;"))
   true
   sage: print(magma.eval("phi(X26 ! [0, 1, 1]) eq 2*Q;"))
   true
   sage: print(magma.eval("phi(X26 ! [1, 1, 0]) eq 2*Q;"))
   true
   sage: magma.eval("L<s> := QuadraticField(13);");
   sage: magma.eval("X26L := BaseChange(X26, L);");
   sage: magma.eval("phiL := phi(L);");
   sage: print(magma.eval("X26modW2 ! phiL(X26L ! [1, s, -1]) eq 3*Q;"))
   true
   sage: print(magma.eval("X26modW2 ! phiL(X26L ! [-1, s, 1]) eq 3*Q;"))
   true

We now look at the case :math:`l = 3` and check that the corresponding
curve :math:`X_0(6)` is a rational curve.

::

   sage: magma.eval("X6 := SmallModularCurve(6);");
   sage: magma.eval("w2 := AtkinLehnerInvolution(X6, 6, 2);");
   sage: print(magma.eval("Genus(X6);"))
   0

We will now check that the morphism :math:`\phi` given in the article
indeed quotients out the action of :math:`w_2`. For this we only have
to check that :math:`\phi \circ w_2 = \phi` as :math:`\phi` clearly
has degree 2 by definition.

::

   sage: magma.eval("R<x,y> := PolynomialRing(Rationals(), 2);");
   sage: magma.eval("P1 := ProjectiveSpace(R);");
   sage: magma.eval("phi := map< X6 -> P1 | [x*(x + 9*y), y*(x + 8*y)]>;");
   sage: print(magma.eval("w2 * phi eq phi"))
   true

Last we look at the case :math:`l = 5`. We again check that
:math:`X_0(10)` is a rational curve.

::

   sage: magma.eval("X10 := SmallModularCurve(10);");
   sage: magma.eval("w2 := AtkinLehnerInvolution(X10, 10, 2);");
   sage: print(magma.eval("Genus(X10);"))
   0

Next we check that the morphism :math:`\phi` as given in the article
indeed quotients out the action of :math:`w_2`, by checking that
:math:`\phi \circ w_2 = \phi`. This is sufficient since :math:`\phi`
clearly has degree 2.

::

   sage: magma.eval("R<x,y> := PolynomialRing(Rationals(), 2);");
   sage: magma.eval("P1 := ProjectiveSpace(R);");
   sage: magma.eval("phi := map< X10 -> P1 | [x*(x + 5*y), y*(x + 4*y)]>;");
   sage: print(magma.eval("w2 * phi eq phi"))
   true

We now turn back to our elliptic curves and check that the
decomposition field of both curves is indeed the given field
:math:`K_{\text{dec}}` as in the article.

::

   sage: Q120.<zeta120> = CyclotomicField(120)
   sage: Hdec = [s for s in Q120.galois_group() if s(zeta120) == zeta120^91]
   sage: Kdec = fixed_field(Hdec)
   sage: E1.decomposition_field().is_isomorphic(Kdec)
   True
   sage: E2.decomposition_field().is_isomorphic(Kdec)
   True

We check that the restriction of scalars of these elliptic curves over
:math:`K_{\text{dec}}` does not decompose, but the twists of both
curves by the element :math:`\gamma` as in the article does.

::

   sage: E1.does_decompose()
   False
   sage: E2.does_decompose()
   False
   sage: f = x^8 - 40*x^7 - 550*x^6 - 1840*x^5 - 285*x^4 + 3600*x^3 - 1950*x^2 + 200*x + 25
   sage: gamma = f.change_ring(Kdec).roots()[0][0]
   sage: E1c = E1.twist(gamma)
   sage: E2c = E2.twist(gamma)
   sage: iota = E1c.definition_field().hom([Kdec(g) for g in E1c.definition_field().gens()], Kdec)
   sage: E1c = E1c.change_ring(iota)
   sage: E2c = E2c.change_ring(iota)
   sage: E1c.does_decompose()
   True
   sage: E2c.does_decompose()
   True

We now compute the quantities presented in proposition 3.6. First the
discriminants.

::

   sage: iota = E1.definition_field().embeddings(Kdec)[1]
   sage: E1c.discriminant() == gamma^6 * (2^13 * 3 * 5^4 * w * g1 * g2^2).change_ring(iota)
   True
   sage: E2c.discriminant() == gamma^6 * (2^9 * 3^6 * 5^4 * (w - 5) * g1^2 * g2).change_ring(iota)
   True
   
We also compute the conductors over the decomposition field of both
twisted versions.

::

   sage: N1c = E1c.conductor(); N1c
   Warning: Assuming that a and b are coprime.
   (128)*Rad_P( ((2263122465000000*zeta1200^15 + 1923257904000000*zeta1200^14 + 2212566120000000*zeta1200^13 - 2661718800000000*zeta1200^12 - 7487229096000000*zeta1200^11 - 3290069280000000*zeta1200^10 - 6915484368000000*zeta1200^9 + 4066736640000000*zeta1200^8 - 17700528960000000*zeta1200^7 - 17611849344000000*zeta1200^6 - 57280067520000000*zeta1200^5 - 8903144448000000*zeta1200^4 + 104317424640000000*zeta1200^3 + 137816110080000000*zeta1200^2 + 239591331072000000*zeta1200 - 87077376000000000)) * (a^2 + (1/128*zeta1200^15 + 1/48*zeta1200^13 - 1/48*zeta1200^11 - 1/24*zeta1200^9 - 1/6*zeta1200^7 - 1/6*zeta1200^5 + 2/3*zeta1200 + 2)*b^2) * (a^2 + (-1/128*zeta1200^15 - 1/48*zeta1200^13 + 1/48*zeta1200^11 + 1/24*zeta1200^9 + 1/6*zeta1200^7 + 1/6*zeta1200^5 - 2/3*zeta1200 + 2)*b^2)^2 )
   sage: N2c = E2c.conductor(); N2c
   Warning: Assuming that a and b are coprime.
   (2, -1/128*zeta1200^15 + 1/128*zeta1200^14 + 1/32*zeta1200^11 - 1/32*zeta1200^10 - 1/8*zeta1200^7 + 1/8*zeta1200^6 - 1/4*zeta1200^5 + 1/4*zeta1200^4 - zeta1200^3 + zeta1200^2 - 2*zeta1200 + 1)^n0*(2, -1/128*zeta1200^15 + 1/128*zeta1200^14 + 1/32*zeta1200^11 - 1/32*zeta1200^10 - 1/8*zeta1200^7 + 1/8*zeta1200^6 - 1/4*zeta1200^5 + 1/4*zeta1200^4 - zeta1200^3 + zeta1200^2 - zeta1200 + 2)^n1*(3, 1/16*zeta1200^8 + 1/8*zeta1200^7 + 1/4*zeta1200^5 - 1/4*zeta1200^4 - 1/2*zeta1200^3 - zeta1200 + 1)*(3, 1/16*zeta1200^8 - 1/8*zeta1200^7 - 1/4*zeta1200^5 - 1/4*zeta1200^4 + 1/2*zeta1200^3 + zeta1200 + 1)*(1)*(1)*Rad_P( ((65747601802687500*zeta1200^15 + 55873929255750000*zeta1200^14 + 64278765445500000*zeta1200^13 - 77327474337000000*zeta1200^12 - 217516972603500000*zeta1200^11 - 95582019978000000*zeta1200^10 - 200906790345000000*zeta1200^9 + 118145857392000000*zeta1200^8 - 514230123564000000*zeta1200^7 - 511654788180000000*zeta1200^6 - 1664083573164000000*zeta1200^5 - 258653416536000000*zeta1200^4 + 3030605390160000000*zeta1200^3 + 4003791498432000000*zeta1200^2 + 6960543123312000000*zeta1200 - 2529759872808000000)) * (a^2 + (-1/128*zeta1200^15 - 1/48*zeta1200^13 + 1/48*zeta1200^11 + 1/24*zeta1200^9 + 1/6*zeta1200^7 + 1/6*zeta1200^5 - 2/3*zeta1200 + 2)*b^2) * (a^2 + (1/128*zeta1200^15 + 1/48*zeta1200^13 - 1/48*zeta1200^11 - 1/24*zeta1200^9 - 1/6*zeta1200^7 - 1/6*zeta1200^5 + 2/3*zeta1200 + 2)*b^2)^2 )
    where 
   n0 =  12 if ('a', 'b') == (1, 0) mod 2
         10 if ('a', 'b') == (1, 1) mod 2
   n1 =  12 if ('a', 'b') == (1, 0) mod 2
         10 if ('a', 'b') == (1, 1) mod 2

The expression here can be quite unreadable, therefore we check that
it matches the much more readable expression in the paper.

::

   sage: P2, Q2 = Kdec.primes_above(2)
   sage: P3, Q3 = Kdec.primes_above(3)
   sage: P5, Q5 = Kdec.primes_above(5)
   sage: N1c.left() == P2^14 * Q2^14 * P3^0 * Q3^0 * P5^0 * Q5^0
   True
   sage: N1c.right() == "Rad_P( " + str(E1c.discriminant().factor()) + " )"
   True
   sage: e = N2c.left().left().left().left().left().left().right(); e
   12 if ('a', 'b') == (1, 0) mod 2
   10 if ('a', 'b') == (1, 1) mod 2
   sage: N2c.left() == P2^e * Q2^e * P3^2 * Q3^2 * P5^0 * Q5^0
   True
   sage: N2c.right() == "Rad_P( " + str(E2c.discriminant().factor()) + " )"
   True

The radical is taken outside the primes of possible additive
reduction. We check that for both curves this is indeed the set given
in the article.

::

   sage: Pbad = Kdec.primes_above(2*3*5)
   sage: Set(E1c.primes_of_possible_additive_reduction()) == Set(Pbad)
   True
   sage: Set(E2c.primes_of_possible_additive_reduction()) == Set(Pbad)
   True

For corollary 3.7 we check that the only primes that ramify in
:math:`K_{\text{dec}}` are those above 2, 3 and 5, by checking that
these are the only prime factors of the discriminant.

::

   sage: Kdec.discriminant().prime_factors()
   [2, 3, 5]

Next we check that for each prime in :math:`K_{\text{dec}}` not above
2, 3 or 5 the valuation of the discriminant at that prime is divisible
by :math:`l`. This is the case if the prime divides only the factors
:math:`g_1` and :math:`g_2` in the discriminant, so we check that the
remaining factors are only divisible by primes above 2, 3 and 5. This
we do by checking they are integral and then computing the prime
numbers in their norm.

::

   sage: D1l = (E1c.discriminant() / (g1 * g2^2).change_ring(iota)).numerator().constant_coefficient()
   sage: D1l.is_integral()
   True
   sage: ZZ(D1l.norm()).prime_factors()
   [2, 3, 5]
   sage: D2l = (E2c.discriminant() / (g1^2 * g2).change_ring(iota)).numerator().constant_coefficient()
   sage: D2l.is_integral()
   True
   sage: ZZ(D2l.norm()).prime_factors()
   [2, 3, 5]

We now compute the possible levels of the newforms which agrees with
those given in theorem 3.8. Note that the code gives a list of
possibilities consisting of tuples of levels, one level for each
abelian variety that is a factor of the restriction of scalars. For
our newform elimination we only want the lowest level of each tuple.

::

   sage: E1c.newform_levels(bad_primes=Pbad)
   [(15360, 15360, 76800, 76800), (76800, 76800, 15360, 15360)]
   sage: E2c.newform_levels(bad_primes=Pbad)
   [(23040, 23040, 115200, 115200), (115200, 115200, 23040, 23040)] if ('a', 'b') == (1, 0) mod 2 and ('a', 'b') == (1, 0) mod 2
   []                                                               if ('a', 'b') == (1, 0) mod 2 and ('a', 'b') == (1, 1) mod 2 or ('a', 'b') == (1, 1) mod 2 and ('a', 'b') == (1, 0) mod 2
   [(11520, 11520, 57600, 57600), (57600, 57600, 11520, 11520)]     if ('a', 'b') == (1, 1) mod 2 and ('a', 'b') == (1, 1) mod 2

We also check that the corresponding character is one of the two
mentioned in theorem 3.8. As mentioned in the article, the character
is the inverse of the corresponding splitting character. We compute
all splitting characters corresponding to the factors of the
restriction of scalars and find that they are one of the two mentioned
in the article.

::

   sage: [eps for eps in DirichletGroup(15) if eps.conductor() == 15 and eps.order() == 4]
   [Dirichlet character modulo 15 of conductor 15 mapping 11 |--> -1, 7 |--> zeta4,
    Dirichlet character modulo 15 of conductor 15 mapping 11 |--> -1, 7 |--> -zeta4]
   sage: E1c.splitting_character('conjugacy')
   (Dirichlet character modulo 15 of conductor 15 mapping 11 |--> -1, 7 |--> zeta4,
    Dirichlet character modulo 15 of conductor 15 mapping 11 |--> -1, 7 |--> zeta4,
    Dirichlet character modulo 15 of conductor 15 mapping 11 |--> -1, 7 |--> -zeta4,
    Dirichlet character modulo 15 of conductor 15 mapping 11 |--> -1, 7 |--> -zeta4)
   sage: E2c.splitting_character('conjugacy')
   (Dirichlet character modulo 15 of conductor 15 mapping 11 |--> -1, 7 |--> zeta4,
    Dirichlet character modulo 15 of conductor 15 mapping 11 |--> -1, 7 |--> zeta4,
    Dirichlet character modulo 15 of conductor 15 mapping 11 |--> -1, 7 |--> -zeta4,
    Dirichlet character modulo 15 of conductor 15 mapping 11 |--> -1, 7 |--> -zeta4)

Now we perform the elimination as mentioned in the last part of
section 3 of the article.

First we load the newforms corresponding to ``E1c``, which are loaded
from the file "tmp/E1.nfs".

::

   sage: nfs1 = E1c.newform_candidates(algorithm='file', path='tmp/E1.nfs')

Since the newforms in this collection have coefficient fields of large
degrees, the code takes very long to compute the composite field of
the coefficient field of each newform and the image field of the
corresponding character. We know however that the latter embeds in the
first in every case, hence we can preload the cache of the method
``composite_field`` to get around this problem. This we do using some
precomputed roots of -1 in the coefficient field of each newform,
which are loaded from the fiel "tmp/nfs1_roots.sobj".

::

   sage: z = load("tmp/nfs1_roots.sobj")
   sage: for i in z:
   ....:     f = nfs1[i]
   ....:     Kf = f.coefficient_field()
   ....:     Lf = f.character().base_ring()
   ....:     mapK = Kf.hom(Kf)
   ....:     mapL = Lf.hom([z[i]], Kf)
   ....:     composite_field.cache[((Kf, Lf, True),())] = (Kf, mapK, mapL)
   ....:     composite_field.cache[((Lf, Kf, True),())] = (Kf, mapL, mapK)
   ....:     composite_field.cache[((Kf, Lf, False),())] = Kf
   ....:     composite_field.cache[((Lf, Kf, False),())] = Kf
   ....:

Next we eliminate the newforms corresponding to ``E1c`` by comparing
traces of Frobenius. We also remove those for the cases :math:`l = 2,
5`.

::

   sage: nfs1 = eliminate_by_traces(E1c, nfs1, condition=coprime, primes=prime_range(7, 40))
   sage: nfs1 = eliminate_primes(E1c, nfs1, 2*5)

Next we do the same for the newforms corresponding to ``E2c``, which
are loaded from the file "tmp/E2.nfs".

::

   sage: nfs2 = E2c.newform_candidates(algorithm='file', path='tmp/E2.nfs')
   sage: nfs2 = eliminate_by_traces(E2c, nfs2, condition=coprime, primes=prime_range(7, 40))
   sage: nfs2 = eliminate_primes(E2c, nfs2, 2*5)

We next combine the two sets of newforms and compare traces of
frobenius for two curves simultaneously to eliminate more newforms. We
also check that the only newforms remaining are for the case :math:`l
= 3`.

::

   sage: nfs = combine_newforms(nfs1, nfs2)
   sage: nfs = eliminate_by_traces((E1c, E2c), nfs, condition=coprime, primes=prime_range(7, 50))
   sage: apply_to_conditional_value(lambda nfsi: lcm(nf[2] for nf in nfsi).prime_factors(), nfs)
   [3]

Now we find the conditions on the variables modulo 29 for the case
:math:`l = 3` and again perform an elimination by comparing traces
using this condition, after which no newforms remain.

::

   sage: analyzer = power_analyzer(cl)
   sage: bad_primes_val = tuple((-1 if P.divides(3) else 0) for P in analyzer.bad_primes(L, h))
   sage: C3 = analyzer.prime_conditions(L, h, 3, primes=[29], bad_primes_val=bad_primes_val)[29]
   sage: nfs = eliminate_by_trace((E1c, E2c), nfs, 29, B=3, condition=C3)
   sage: nfs
   []
