===========================================
 Computations for the case :math:`D = -17`
===========================================

In this document we will perform the computations required to prove
the non-existence of l-th powers (with l a large prime) in some
Elliptic Divisibility Sequences generated by points on
:math:`E_{-17}(\QQ)`. This includes all the computation of Section
5.5.2.

.. linkall

We require the following to run the code below. Note that the file
`frey_curves.sage` is the file in the same directory as this file. If
you try to test this file, please make sure the load path of
`frey_curves.sage` matches the path from the directory you are running
the tests from by editing the code below. Note that the file
`frey_curves.sage` also imports some components from the
`modular_method` package.

::

   sage: from modular_method.diophantine_equations.conditions import apply_to_conditional_value
   sage: load("examples/EDS/frey_curves.sage")

First of all we construct the elliptic curve :math:`E_{-17}` and
compute generators for the abelian group :math:`E_{-17}(\QQ)`.

::

   sage: D = -17
   sage: Em17 = EllipticCurve([0, 0, 0, D, 0])
   sage: P, Q = Em17.gens(); T = Em17.torsion_points()[0]

To use the level lowering result from Proposition 5.3.1 we need that
the denominators of the the points considered are divisible by a prime
larger than 3. We therefore compute all the points on
:math:`E_{-17}(\QQ)` that do not satisfy this property and exclude
them later from our computations.

::

   sage: S_integral_points = [Em17(P.Coordinates().sage()) for P in magma(Em17).SIntegralPoints([2, 3])]
   sage: S_integral_points += [-P for P in S_integral_points]
   sage: compare = [
   ....:     P,
   ....:     Q,
   ....:     T,
   ....:     2*P,
   ....:     2*Q,
   ....:     P + T,
   ....:     Q + T,
   ....:     2*Q + T,
   ....:     P + Q,
   ....:     P - Q,
   ....:     2*P - 2*Q,
   ....:     P - Q + T,
   ....:     P - 2*Q + T,
   ....: ]
   sage: compare += [-P for P in compare]
   sage: assert set(S_integral_points) == set(compare)

We compute all the non-trivial perfect powers among the denominators
of these points. Note that they are all squares.

::

   sage: perfect_powers = [
   ....:     P for P in compare
   ....:     if sqrt(P.xy()[0].denominator()).is_perfect_power() and
   ....:     sqrt(P.xy()[0].denominator()) != 1
   ....: ]
   sage: assert set(perfect_powers) == set([
   ....:     2*P,
   ....:     -2*P,
   ....:     2*Q,
   ....:     -2*Q,
   ....:     2*Q + T,
   ....:     -2*Q + T,
   ....: ])
   sage: sqrt((2*P).xy()[0].denominator())
   4
   sage: sqrt((-2*P).xy()[0].denominator())
   4
   sage: sqrt((2*Q).xy()[0].denominator())
   4
   sage: sqrt((-2*Q).xy()[0].denominator())
   4
   sage: sqrt((2*Q + T).xy()[0].denominator())
   9
   sage: sqrt((-2*Q + T).xy()[0].denominator())
   9

The case a = 1
--------------

First of all we look at the Frey curve :math:`E_{1, z, w}` which
corresponds to points `m*P + n*Q` with `m + n` even.

::

   sage: a = 1
   sage: E1zw = Frey_curve_of_divisibility_sequence(a, D, precision=1)

We compute the conductor exponent of this Frey curve at 2.

::

   sage: e2 = apply_to_conditional_value(lambda E: E.conductor_exponent(2), E1zw)

We know that `B` is at least a square, hence we can apply some
additional conditions.

::

   sage: z, w = E1zw[0][0].parameters()
   sage: con_extra = (CongruenceCondition(w^2 - a*z^4 - 1, 2) |
   ....:              CongruenceCondition(w^2 - a*z^4, 2^8))
   sage: e2 = ConditionalValue([
   ....:     (e, con) for e, con in e2
   ....:     if not (con & con_extra).pAdic_tree(pAdics=pAdicBase(QQ, 2)).is_empty()
   ....: ]); e2
   8 if ('z', 'w') == (1, 0), (3, 0) mod 4
   0 if ('z', 'w') is 1 of 256 possibilities mod 256
   1 if ('z', 'w') is 1 of 256 possibilities mod 256

We check that the remaining conditions correspond to the ones in Table
5.1.

::

   sage: assert all(mod(ww^2 - a*zz^4, 2) == 1
   ....:            for zz, ww in e2[0][1].pAdic_tree().give_as_congruence_condition()[0])
   sage: assert all(mod(ww^2 - a*zz^4, 2^9) == 2^8
   ....:            for zz, ww in e2[1][1].pAdic_tree().give_as_congruence_condition()[0])
   sage: assert all(mod(ww^2 - a*zz^4, 2^9) == 0
   ....:            for zz, ww in e2[2][1].pAdic_tree().give_as_congruence_condition()[0])

Finally we assert that the conductor exponent at 17 is always 1.

::

   sage: apply_to_conditional_value(lambda E: E.conductor_exponent(17), E1zw)
   1

We can now compute the newform candidates to eliminate. Note that the
default method does not take into account our additional condition, so
we filter afterwards.

::

   sage: Enfs1 = apply_to_conditional_value(
   ....:     lambda E: apply_to_conditional_value(
   ....:         lambda nfs: (E, nfs),
   ....:         E.newform_candidates(
   ....:             bad_primes=[2,17],
   ....:             algorithm='magma',
   ....:         ),
   ....:     ),
   ....:     E1zw,
   ....: )
   sage: Enfs1 = ConditionalValue([
   ....:     (Enfs, con) for Enfs, con in Enfs1
   ....:     if not (con & con_extra).pAdic_tree(pAdics=pAdicBase(QQ, 2)).is_empty()
   ....: ])

We confirm that the total number of newforms agrees with what is
mentioned in Section 5.5.2.

::

   sage: apply_to_conditional_value(lambda Enfs: len(Enfs[1]), Enfs1)
   33 if ('z', 'w') == (1, 0), (3, 0) mod 4
   1  if ('z', 'w') is 1 of 128 possibilities mod 128

Now we perform elimination by comparing traces of Frobenius at the
primes :math:`p < 50` with :math:`p \neq 2, 17`.

::

   sage: Enfs1 = apply_to_conditional_value(
   ....:     lambda Enfs: (Enfs[0], eliminate_by_traces(
   ....:         Enfs[0],
   ....:         Enfs[1],
   ....:         condition=CoprimeCondition([z, w]),
   ....:         primes=[p for p in prime_range(50) if not p.divides(2*17)],
   ....:     )),
   ....:     Enfs1,
   ....: )

We check that the number of newforms that could not be eliminated
agrees with the result in Section 5.5.2. Furthermore we check that all
the others are eliminated for all prime exponents :math:`l > 5`.

::

   sage: apply_to_conditional_value(lambda Enfs: sum(1 for nf in Enfs[1] if nf[-1] == 0), Enfs1)
   8 if ('z', 'w') == (1, 0), (3, 0) mod 4
   1 if ('z', 'w') is 1 of 128 possibilities mod 128
   sage: apply_to_conditional_value(
   ....:     lambda Enfs: lcm(nf[-1] for nf in Enfs[1] if nf[-1] != 0).prime_factors(),
   ....:     Enfs1,
   ....: )
   [2, 3, 5, 7] if ('z', 'w') == (1, 0), (3, 0) mod 4
   []           if ('z', 'w') is 1 of 128 possibilities mod 128

We check that all the newforms that could not be eliminated are
rational.

::

   sage: bad_nfs = [nf[0] for Enfs, _ in Enfs1 for nf in Enfs[1] if nf[-1] == 0]
   sage: assert all(nf.coefficient_field() == QQ for nf in bad_nfs)

Next we compute for each of these newforms the j-invariant of the
corresponding elliptic curve. From this we compute the possible values
of :math:`(z, w)` for which the j-invariant of `E1zw` might be the
same. Next we determine for each of these :math:`(z, w)` whether a
corresponding :math:`B` satisfying equation (5.5) can exist. If not we
label it as a pseudo solution.

::

   sage: bad_j = set(nf._f.EllipticCurve().sage().j_invariant() for nf in bad_nfs)
   sage: E1zwj = E1zw[0][0].j_invariant()
   sage: polys = set(poly for Efj in bad_j for poly, _ in (E1zwj - Efj).numerator().factor()
   ....:             if poly.degree(w) == 1)
   sage: wdivzsq = set(-poly(1, 0) / poly(0, 1) for poly in polys)
   sage: zw = [(sqrt(val.denominator()), val.numerator()) for val in wdivzsq if val.denominator().is_square()]
   sage: assert all(any(poly(z_, w_) == 0 for poly in polys) for z_, w_ in zw)
   sage: def tmp(val):
   ....:     try:
   ....:         return val.nth_root(4)
   ....:     except ValueError:
   ....:         return 'pseudo'
   sage: [(z_, w_, tmp((w_^2 - z_^4) / (-17))) for z_, w_ in zw]
   [(3, -8, 1),
    (15, 353, 'pseudo'),
    (3, 8, 1),
    (12, -145, 'pseudo'),
    (12, 145, 'pseudo'),
    (23, 495, 'pseudo')]

Now we limit ourself to all points which are multiples of `2*P +
2*Q`. For all of them `B` is divisible by the prime numbers dividing
the denominator of `2*P + 2*Q`, which in this case are 2, 3, and 7. We
compute the additional conditions this imposes.

::

   sage: P1 = 2*P + 2*Q; P1.xy()
   (3568321/451584, 5750178337/303464448)
   sage: P1.xy()[0].denominator().prime_factors()
   [2, 3, 7]
   sage: C2 = CongruenceCondition(w^2 - a*z^4, 2)
   sage: C3 = CongruenceCondition(w^2 - a*z^4, 3)
   sage: C7 = CongruenceCondition(w^2 - a*z^4, 7)

We filter then newforms using the additional condition `C2`.

::

   sage: Enfs1P = ConditionalValue([
   ....:     (Enfs, C & C2) for Enfs, C in Enfs1
   ....:     if not (C & C2).pAdic_tree(pAdics=pAdicBase(QQ, 2)).is_empty()
   ....: ])

Next we perform elimination again at the primes 3 and 7 using the
additional conditions `C3` and `C7`. We see that with all this
additional information all newforms can be elimination when :math:`l >
3`.

::

   sage: Enfs1P = apply_to_conditional_value(
   ....:     lambda Enfs: (Enfs[0], eliminate_by_traces(
   ....:         Enfs[0],
   ....:         Enfs[1],
   ....:         condition=CoprimeCondition([z, w]) & C3 & C7,
   ....:         primes=[3, 7],
   ....:     )),
   ....:     Enfs1P,
   ....: )
   sage: apply_to_conditional_value(lambda Enfs: [nf[-1].prime_factors() for nf in Enfs[1]], Enfs1P)
   [[2, 3]]

The case a = -17
----------------

Now we look at the Frey curve :math:`E_{3, z, w}` which corresponds to
points `m*P + n*Q + T` with `m + n` even
::

   sage: a = -17
   sage: Em17zw = Frey_curve_of_divisibility_sequence(a, D, precision=1)

We check that `Em17zw` is completely defined over :math:`K =
\QQ(\sqrt{2}, \sqrt{-17})`, as is a splitting map.

::

   sage: K = Em17zw.decomposition_field()
   sage: assert K.is_isomorphic(QQ[sqrt(2), sqrt(-17)])

We verify that the trivial character is a splitting character for
`Em17zw`.

::

   sage: assert Em17zw.splitting_character().conductor() == 1

Next we compute the tables of 2-cocycles corresponding to `Em17zw` and
a splitting map. We use the same notation as in Section 5.5.2 for the
Galois elements.

::

   sage: G = K.galois_group()
   sage: sqrt2, sqrtm17 = sqrt(K(2)), sqrt(K(-17))
   sage: s2 = next(s for s in G if s != G(1) and s(sqrt2) == sqrt2)
   sage: s17 = next(s for s in G if s != G(1) and s(sqrtm17) == sqrtm17)
   sage: Gls = [G(1), s2, s17, s2*s17]
   sage: matrix([[Em17zw.c(s, t) for t in Gls] for s in Gls])
   [ 1  1  1  1]
   [ 1  2  1  2]
   [ 1 -1  1 -1]
   [ 1 -2  1 -2]
   sage: matrix([[Em17zw.c_splitting_map(s, t) for t in Gls] for s in Gls])
   Warning: The restriction of scalars of this Q-curve over the decomposition field does not decompose into abelian varieties of GL_2-type. Use the method decomposable_twist to find a twist that does.
   [1 1 1 1]
   [1 2 1 2]
   [1 1 1 1]
   [1 2 1 2]

We confirm that the unit group of :math:`K` is generated by :math:`-1`
and :math:`\sqrt{2} - 1`.

::

   sage: u0, u1 = K.unit_group().gens_values()
   sage: assert u0 == -1 and u1 == sqrt2 - 1

Next we verify that the second map :math:`\alpha` given in Section
5.5.2 indeed has the desired coboundary.

::

   sage: alpha = {
   ....:     G(1): 1,
   ....:     s2: -1,
   ....:     s17: (1 - 3*sqrt2) / sqrtm17,
   ....:     s2*s17: (1 - 3*sqrt2) / sqrtm17,
   ....: }
   sage: assert all(alpha[s] * s(alpha[t]) * alpha[s*t]^(-1) == Em17zw.c(s, t) / Em17zw.c_splitting_map(s, t)
   ....:            for t in G for s in G)

We also check that the element :math:`\gamma` given in Section 5.5.2
has coboundary :math:`\alpha^2`.

::

   sage: gamma = 1 + 3*sqrt2
   sage: assert all(s(gamma) == alpha[s]^2 * gamma for s in G)

We check that the elliptic curve `Em17zw` twisted by :math:`\gamma`
has a restriction of scalar over :math:`K` that decomposes as a
product of abelian varieties of GL_2-type. Furthermore we check that
:math:`K` is both the definition field and decomposition field of this
twisted curve.

::

   sage: Em17zwg = Em17zw.twist(gamma)
   sage: assert Em17zwg.does_decompose()
   sage: assert K == Em17zwg.definition_field()
   sage: assert K == Em17zwg.decomposition_field()

We compute the conductor of the curve `Em17zwg` and verify it matches
the expression in Section 5.5.2.

::

   sage: Nm17 = Em17zwg.conductor(additive_primes=K.primes_above(2*17)); Nm17
   (2, 1/76*lu^3 - 1/4*lu^2 + 11/76*lu - 11/4)^n0*(17, 1/38*lu^3 + 11/38*lu + 6)*(17, 1/38*lu^3 + 11/38*lu - 6)*Rad_P( ((-8716055040/19*lu^3 - 95876605440/19*lu - 27576944128)) * (z^2 + (-1/646*lu^3 - 49/646*lu)*w) * (z^2 + (1/646*lu^3 + 49/646*lu)*w)^2 )
    where
   n0 = 16 if ('z', 'w') == (1, 0), (3, 0) mod 4
        6  if ('z', 'w') is 1 of 8 possibilities mod 8
   sage: assert (Nm17.left().right() * Nm17.left().left().right() == K.ideal(17) and
   ....:         Nm17.left().left().left().left() == K.prime_above(2))
   sage: z, w = Em17zw.parameters()
   sage: z = z.change_ring(QQ); w = w.change_ring(QQ)
   sage: assert 17*product(p for p, _ in Em17zwg.discriminant().factor()) == w^2 - a*z^4
   sage: Nm17.left().left().left().right()[1]
   (6,
    The condition that ('z', 'w') == (0, 1), (0, 7), (2, 1), (2, 7), (4, 1), (4, 7), (6, 1), (6, 7) mod 8)

Next we verify that we get the same levels for the newforms after
level lowering as in Section 5.5.2.

::

   sage: levels = Em17zwg.newform_levels(bad_primes=K.primes_above(2*17)); levels
   [(73984, 73984)]               if ('z', 'w') == (1, 0), (3, 0) mod 4
   [(9248, 18496), (18496, 9248)] if ('z', 'w') is 1 of 8 possibilities mod 8
   sage: assert (73984 == 2^8 * 17^2 and
   ....:         18496 == 2^6 * 17^2 and
   ....:         9248 == 2^5 * 17^2)

We compute the newforms of these levels. We only include only one
newform per conjugacy class, as otherwise the necessary number field
computations take too long.

::

   sage: nfsm17 = Em17zwg.newform_candidates(bad_primes=K.primes_above(2*17), algorithm='magma', conjugates=False)

We eliminate newforms by comparing traces of Frobenius at the primes
mentioned in Section 5.5.2. Note that we use the option `use_minpoly`
here as enabling this option can immediately exclude an entire
conjugacy class of newforms. Since we only have one newform per
conjugacy class we need to do this for the correct result.

::

   sage: primes = [3, 5, 7, 11, 13, 19, 29, 31, 37, 41, 43, 47, 59, 67, 73, 97, 113]
   sage: nfsm17 = eliminate_by_traces(Em17zwg, nfsm17, condition=CoprimeCondition([z, w]),
   ....:                              primes=primes, use_minpoly=True)

We check that after this elimination there remain 10 newforms and the
others are eliminated for all prime exponents :math:`l > 31`.

::

   sage: apply_to_conditional_value(lambda nfs: sum(1 for nf in nfs if nf[-1] == 0), nfsm17)
   6 if ('z', 'w') == (1, 0), (3, 0) mod 4
   4 if ('z', 'w') is 1 of 8 possibilities mod 8
   sage: apply_to_conditional_value(lambda nfs: lcm(nf[-1] for nf in nfs if nf[-1] != 0).prime_factors(), nfsm17)
   [2, 3, 5, 7, 13, 17, 23, 31] if ('z', 'w') == (1, 0), (3, 0) mod 4
   [2, 7, 13, 17]               if ('z', 'w') is 1 of 8 possibilities mod 8

Now we limit ourself to all points which are multiples of `P + Q + T`.
For all of them `B` is divisible by the prime numbers dividing the
denominator of `P + Q + T`, which in this case is only 7.

::

   sage: P1 = P + Q + T
   sage: P1.xy()[0].denominator().prime_factors()
   [7]

We perform the elimination again at 7, using this additional
condition. We find that all newforms are eliminated in this case
whenever :math:`l > 17` or :math:`l = 3, 11`.

::

   sage: nfsm17P = eliminate_by_trace(Em17zwg, nfsm17, 7,
   ....:                              condition=(CoprimeCondition([z, w]) &
   ....:                                         CongruenceCondition(w^2 - a*z^4, 7)),
   ....:                              use_minpoly=True )
   sage: apply_to_conditional_value(lambda nfs: product(nf[-1] for nf in nfs).prime_factors(), nfsm17P)
   [2, 5, 7, 13, 17] if ('z', 'w') == (1, 0), (3, 0) mod 4
   [2, 7, 17]        if ('z', 'w') is 1 of 8 possibilities mod 8
