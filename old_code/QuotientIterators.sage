from sage.rings.polynomial.multi_polynomial_ring import is_MPolynomialRing

class OrderQuotientIterator:
    r"""
    An iterator for quotients of orders.
    
    An object of this class functions as an iterable object
    that iterates over representatives for a quotient of
    an order in a number field by a nonzero ideal.
    
    EXAMPLES:
    
    
    """
    
    def __init__(self, order, ideal):
        r"""
        Create the iterable.
        
        
        """
        self.order = order
        self.ideal = ideal
        
    def __iter__(self):
        V, fVK, fKV = self.order.number_field().vector_space()
        M = self.order.module()
        N = M.submodule([fKV(g) for g in self.ideal.integral_basis()])
        for a in M.quotient(N):
            yield self.order(fVK(a.lift()))

class PolynomialRingQuotientIterator:
    r"""
    An iterator for quotients of polynomial rings.
    
    This iterator iterates over quotients of polynomial rings if they are
    finite.  Currently this is only implemented for polynomial rings over
    fields and polynomial rings over ZZ.
    
    EXAMPLES:
    
    Suppose we want to make a list of all elements of F_5[x,y] modulo the
    ideal generated by x^2 - y and y^2 + 2*y + 3.
    
        sage: F5 = FiniteField(5)
        sage: R.<x,y> = F_5[]
        sage: I = R.ideal(x^2 - y, y^2 + 2*y + 3)
        sage: ls = list(PolynomialRingQuotientIterator(R, I))
        sage: len(ls)
        625
        
    Suppose we are working over the cyclotomic field and want to find all
    elements modulo 15 that square to -1.  We are thus working inside the
    ring R = ZZ[x]/(phi5(x),15) where phi5 is the fifth cyclotomic
    polynomial.
    
        sage: A.<x> = PolynomialRing(ZZ, 1) #Univariate polynomial ring does not work
        sage: phi = cyclotomic_polynomial(5)
        sage: R = A.quotient([phi,15])
        sage: for a in PolynomialRingQuotientIterator(R.ambient(), R.defining_ideal()):
        ....:     if a^2 + 1 in R.defining_ideal():
        ....:         print(a)
        ....:         
        5*x^3 + 5*x^2 + 7
        5*x^3 + 5*x^2 + 13
        10*x^3 + 10*x^2 + 2
        10*x^3 + 10*x^2 + 8

    If you enter a quotient that is definitely not finite, the iterator
    will tell you so.
    
        sage: F = FiniteField(17)
        sage: R.<x,y> = F[]
        sage: I = R.ideal(y^2 - x^3)
        sage: ls = list(PolynomialRingQuotientIterator(R, I))
        ValueError: The quotient of 'Multivariate Polynomial Ring in x, y
        over Finite Field of size 17' by the ideal 'Ideal (x^3) of
        Multivariate Polynomial Ring in x, y over Finite Field of
        size 17' does not contain finitely many monomials

        sage: R.<x> = ZZ[]
        sage: I = R.ideal(x^2 + 1)
        sage: ls = list(PolynomialRingQuotientIterator(R, I))
        ValueError: The constant terms are not bounded by the ideal,
        hence the quotient is not finite.
    """
    
    def __init__(self, polynomial_ring, ideal):
        r"""
        Create an iterator.
        
        INPUT:
        
        - ``polynomial_ring`` -- A (multivariate) polynomial ring over
          which we take the quotient. The base ring of this polynomial
          ring should be a field or ZZ for this iterator to work.
          
        - ``ideal`` -- The ideal in the ring polynomial_ring for which
          we take the quotient.
          
        EXAMPLES:
        
        Create the iterator for the polynomial ring R = ZZ[x,y]
        with the ideal I = (x^2 + y, y^2 - 3, 5)
        
            sage: R.<x,y> = ZZ[]
            sage: I = R.ideal(x^2 + y, y^2 - 3, 5)
            sage: PolynomialRingQuotientIterator(R, I)
            <__main__.PolynomialRingQuotientIterator instance at 0x7f6063b4db90>

        """
        self.base_ring = polynomial_ring.base()
        self.number_of_variables = len(polynomial_ring.variable_names())  
        self._save_as_MPolynomials(polynomial_ring, ideal)
        self.monomial_ideal = \
            self.polynomial_ring.ideal([g.lt() for g in self._groebner_basis()])
        self.monomial_list = list(MonomialQuotientIterator(self.polynomial_ring,
                                                 self.monomial_ideal))
        self.amount_of_monomials = len(self.monomial_list)
        self.current_polynomial = None
        self._check_iterable()
        if self._need_coefficient_list():
            self.coefficient_list = list(self.base_ring.field())
            self.coefficient_list.remove(0)
     
    def _save_as_MPolynomials(self, polynomial_ring, ideal):
        if is_MPolynomialRing(polynomial_ring):
            self.polynomial_ring = polynomial_ring
            self.ideal = ideal
        else:
            self.polynomial_ring = PolynomialRing(
                                        self.base_ring,
                                        self.number_of_variables,
                                        polynomial_ring.variable_names(),
                                        )
            self.ideal = self.polynomial_ring.ideal(
                           [self.polynomial_ring(g) for g in ideal.gens()] )
                                     
        
    def _groebner_basis(self):
        return self.ideal.groebner_basis()
    
    def _check_iterable(self):
        self._check_iteration_defined()
        self._check_finiteness()
        
    def _check_iteration_defined(self):      
        if not self.base_ring.is_field() and not self.base_ring == ZZ:
            raise NotImplementedError(
                    "The iterator currently only works for polynomial rings over fields and ZZ. The ring '%s' is neither."
                    %self.base_ring
                    )
    
    def _ideal_has_nonzero_constant(self):
        for g in self._groebner_basis():
            if g.is_constant() and not g.is_zero():
                return True
        return False
        
    def _check_finiteness(self):
        if self.base_ring.is_field():
            if not self.base_ring.is_finite():
                raise ValueError("The base field is not finite, hence the quotient is not finite.")
        else:
            if not self._ideal_has_nonzero_constant():
                raise ValueError("The constant terms are not bounded by the ideal, hence the quotient is not finite.")
    
    def _need_coefficient_list(self):
        return self.base_ring.is_field()
    
    def _zero_list(self, length):
        return [self.base_ring.zero()] * length
    
    def _current_coefficient(self, index):
        if self._need_coefficient_list():
            return self.coefficient_list[self.current_coefficients[index]]
        else:
            return ZZ(self.current_coefficients[index] + 1)
    
    def _construct_polynomial(self):
        result = self.polynomial_ring.zero()
        for i in range(self.current_length):
            result += self._current_coefficient(i) * self.current_monomials[i]
        return result
    
    def _current_monomial(self, index):
        coefficient = self.current_polynomial.monomial_coefficient(
                                                     self.monomial_list[index])
        return coefficient * self.monomial_list[index]
        
    def _is_valid_coefficient(self, i):
        return self._current_monomial(i) not in self.monomial_ideal
                
    def __iter__(self):
        return self
    
    def next(self):
        if self.current_polynomial is None:
            self.current_polynomial = self.polynomial_ring.zero()
            return self.current_polynomial
        if self.current_polynomial is not None:
            i = 0
            while i < self.amount_of_monomials:
                self.current_polynomial += self.monomial_list[i]
                if self._is_valid_coefficient(i):
                    return self.current_polynomial
                self.current_polynomial -= self._current_monomial(i)
                i += 1
        raise StopIteration
        
class MonomialQuotientIterator:
    r"""
    An iterator for monomials in quotients of polynomial rings.
    
    This iterator will iterate over monomials in a polynomial rings
    that are not inside a given monomial ideal of that ring. This
    provides the building blocks for representatives of elements in
    the quotient of a polynomial ring by any ideal.
    
    EXAMPLES:
    
    Suppose we want to represent the elements of the ring
    QQ[x,y,z] / (x^2 + 3*y*z - x*y, y^3*z + 4*x*y^2 - 12*y, z^4 + 12)
    in a unique way. For this we generate a list of monomials that
    can be in our representatives. Note that we have to replace our
    ideal with the monomial ideal generated by the leading terms
    of elements of a groebner basis of the original ideal.
    
        sage: R.<x,y,z> = QQ[]
        sage: I = R.ideal(x^2 + 3*y*z - x*y, y^3*z + 4*x*y^2 - 12*y, z^4 + 12)
        sage: J = R.ideal([g.lt() for g in I.groebner_basis()])
        sage: ls = list(MonomialQuotientIterator(R, J))
        sage: print(ls)
        [1, x, y, x*y, y^2, x*y^2, y^3, x*y^3, y^4, z, x*z, y*z,
        x*y*z, y^2*z, x*y^2*z, z^2, x*z^2, y*z^2, x*y*z^2, y^2*z^2,
        z^3, x*z^3, y*z^3, y^2*z^3]
    
    It is not possible to iterate over monomials if there are not
    finitely many that are not in the given monomial ideal, e.g.
    
        sage: R = QQ[x,y]
        sage: I = R.ideal(x^2)
        sage: for a in MonomialQuotientIterator(R, I):
        ....:     print(a)
        ....:
        ValueError: The quotient of 'Multivariate Polynomial Ring
        in x, y over Rational Field' by the ideal 'Ideal (x^2) of
        Multivariate Polynomial Ring in x, y over Rational Field'
        does not contain finitely many monomials
        
    """
    
    def __init__(self, polynomial_ring, monomial_ideal):
        self.number_of_variables = len(polynomial_ring.variable_names())
        self._save_as_MPolynomials(polynomial_ring, monomial_ideal)
        self.degrees = None
        self.maximal_monomial = \
            lcm( [ g.lt() for g in self._groebner_basis()] )
        self._check_iterable()
    
    def _save_as_MPolynomials(self, polynomial_ring, ideal):
        if is_MPolynomialRing(polynomial_ring):
            self.polynomial_ring = polynomial_ring
            self.monomial_ideal = ideal
        else:
            self.polynomial_ring = PolynomialRing(
                                        polynomial_ring.base_ring(),
                                        self.number_of_variables,
                                        polynomial_ring.variable_names(),
                                        )
            self.monomial_ideal = self.polynomial_ring.ideal(
                           [self.polynomial_ring(g) for g in ideal.gens()] )
    
    def _groebner_basis(self):
        return self.monomial_ideal.groebner_basis()
            
    def _maximal_degrees(self):
        return self.maximal_monomial.degrees()
    
    def _check_iterable(self):
        self._check_finiteness()
                 
    def _check_finiteness(self):
        seenVariables = [0] * self.number_of_variables
        for g in self._groebner_basis():
            n = 0
            j = -1
            degrees = g.lt().degrees()
            for i in range(self.number_of_variables):
                if degrees[i] > 0:
                    n += 1
                    j = i
            if n == 1:
                seenVariables[j] = 1
        if sum(seenVariables) != self.number_of_variables:
            raise ValueError("The quotient of '%s' by the ideal '%s' does not contain finitely many monomials"
                             %(self.polynomial_ring ,self.monomial_ideal)) 
    
    def __iter__(self):
        return self
    
    def next(self):
        m = self._next_unchecked()
        while m in self.monomial_ideal:
            m = self._next_unchecked()
        return m
    
    def _next_unchecked(self):
        i = 0
        if self.degrees == None:
            self.degrees = [0] * self.number_of_variables
        else:
            while True:
                self.degrees[ i ] += 1
                if self.degrees[ i ] < self._maximal_degrees()[ i ]:
                    break
                self.degrees[ i ] = 0
                i += 1
                if i >= self.number_of_variables:
                    raise StopIteration
        return self.polynomial_ring.monomial(*self.degrees)
